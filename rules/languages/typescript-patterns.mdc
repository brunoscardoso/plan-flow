---
description: "TypeScript best practices and strict typing patterns"
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---

# TypeScript Best Practices & Patterns

## 1. Enable Strict Type-Checking

Ensure `strict: true` is enabled in `tsconfig.json` for rigorous type-checking.

## 2. Prefer Interfaces for Object Shapes

Use interfaces to define object structures:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
}
```

Reserve type aliases for unions, intersections, and complex type compositions.

## 3. Utilize Discriminated Unions for State Management

Model exclusive states with discriminated unions:

```typescript
type RequestState =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: User }
  | { status: "error"; error: Error };
```

## 4. Leverage Generics for Reusable Components

Use generics for flexible, type-safe components:

```typescript
class Cache<T> {
  private data: Map<string, T> = new Map();
  set(key: string, value: T): void { this.data.set(key, value); }
  get(key: string): T | undefined { return this.data.get(key); }
}
```

## 5. Implement Custom Error Types

```typescript
class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ValidationError";
  }
}
```

## 6. Utilize Utility Types

Use TypeScript's built-in utility types: `Partial<T>`, `Required<T>`, `Readonly<T>`, `Pick<T, K>`, `Omit<T, K>`, `Record<K, T>`.

## 7. Avoid the `any` Type

Use `unknown` with type guards instead of `any`:

```typescript
let value: unknown;

if (typeof value === "string") {
  console.log(value.toUpperCase());
}
```

## 8. Enable Null Safety

Use optional chaining and nullish coalescing:

```typescript
const name = user?.profile?.name;
const displayName = name ?? "Anonymous";
```

## 9. Prefer `const` Assertions for Literal Types

```typescript
const roles = ["admin", "user", "guest"] as const;
const response = { status: "active", code: 200 } as const;
```

## 10. Use Type Guards for Runtime Type Checking

```typescript
function isDog(animal: Dog | Cat): animal is Dog {
  return (animal as Dog).bark !== undefined;
}
```

## 11. Prefer Immutability

Use `readonly` and `ReadonlyArray` for immutable data:

```typescript
interface Config {
  readonly apiUrl: string;
  readonly timeout: number;
}

function processItems(items: ReadonlyArray<string>) {
  // items.push('new'); // Error
}
```

## 12. Use `satisfies` Operator

Validate types while preserving narrower types:

```typescript
type Colors = "red" | "green" | "blue";

const palette = {
  primary: "red",
  secondary: "blue",
} satisfies Record<string, Colors>;
```
